<!DOCTYPE html>
<html>
  <head>
    <title>Skeleton for a VR application</title>
    <meta charset="utf-8"/>
  </head>
  <body>
    <script type="module">
      import * as THREE from './js/three.module.js';
      
      
      // Peg State Arrays (Tracks which disks are on each peg)
      const pegState = [[0, 1, 2], [], []]; // Peg 0 has all disks initially (0: largest, 2: smallest)
      const disks = []; // To store the disk meshes for easy access
      const pegs = [];  // To store peg meshes for easy access

      // Interaction Variables
      let selectedDisk = null;
      let selectedPeg = null;

      // Basic setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Room (BoxGeometry)
      const roomGeometry = new THREE.BoxGeometry(15, 15, 15);
      const roomMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.BackSide });
      const room = new THREE.Mesh(roomGeometry, roomMaterial);

      // Base (BoxGeometry)
      const baseGeometry = new THREE.BoxGeometry(12, 0.5, 6);
      const baseMaterial = new THREE.MeshBasicMaterial({ color: 0x8b4513 });
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = -3;
      room.add(base);
      //scene.add(base);

      // Pegs (CylinderGeometry)
      const pegGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 32);
      const pegMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

      const peg1 = new THREE.Mesh(pegGeometry, pegMaterial);
      peg1.position.set(-3.5, -1, 0);
      //scene.add(peg1);
      room.add(peg1);

      const peg2 = peg1.clone();
      peg2.position.set(0, -1, 0);
      //scene.add(peg2);
      room.add(peg2);

      const peg3 = peg1.clone();
      peg3.position.set(3.5, -1, 0);
      //scene.add(peg3);
      room.add(peg3);

      // Store peg meshes in array for easier access
      pegs.push(peg1, peg2, peg3);

      // Disks (CylinderGeometry) - Larger and Properly Positioned
      const diskColors = [0xff5733, 0x33c4ff, 0x75ff33]; // Colors for disks (Orange, Blue, Green)
      const diskHeight = 0.5; // Height of each disk

      for (let i = 0; i < 3; i++) {
        const radius = 2.0 - i * 0.4; // Disk sizes (largest to smallest)
        const diskGeometry = new THREE.CylinderGeometry(radius, radius, diskHeight, 32);
        const diskMaterial = new THREE.MeshBasicMaterial({ color: diskColors[i] });
        const disk = new THREE.Mesh(diskGeometry, diskMaterial);

        disk.userData = { index: i }; // Store disk index for reference
        disks.push(disk);

        // Position the disk on the first peg
        disk.position.set(-3.5, -2.5 + i * (diskHeight + 0.1), 0); // Adjusted y-position to stack properly
        //scene.add(disk);
        room.add(disk);
      }
      
      scene.add(room);
      
      //console.log(disks)

      // Raycaster for interaction
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      
      function onPointerMove( event ) {

          // calculate pointer position in normalized device coordinates
          // (-1 to +1) for both components

          pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
          pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

      }

      function animate() {
          requestAnimationFrame(animate);

          // Update the picking ray
          raycaster.setFromCamera(pointer, camera);

          // Reset all objects' colors and ensure visibility
          room.children.forEach((child) => {
              if (child.material && child.material.color) {
                  child.material.color.set(child.userData.originalColor || 0x000000); // Reset to original color
              }
              child.visible = true; // Ensure all objects remain visible
          });

          // Check for intersections and highlight intersected objects
          const intersects = raycaster.intersectObjects(room.children); //room.children
          intersects.forEach((intersect) => {
              if (intersect.object.material && intersect.object.material.color) {
                  intersect.object.material.color.set(0xff0000); // Highlight intersected object
              }
          });

          renderer.render(scene, camera);
      }

      // Assign unique materials and store original colors
      [peg1, peg2, peg3, base, ...disks].forEach((object) => {
          object.material = object.material.clone(); // Ensure unique material instances
          object.userData.originalColor = object.material.color.getHex(); // Store original color
          object.visible = true; // Ensure objects are visible at start
      });

      // Start animation
      animate();




      window.addEventListener( 'pointermove', onPointerMove );


      
      
      // Event listener for mouse click
      /*window.addEventListener('click', (event) => {
        // Convert mouse coordinates to normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(disks.concat(pegs)); // Raycast against both disks and pegs

        console.log("Mouse Clicked, Intersects:", intersects); // Debugging the raycast hits

        if (intersects.length > 0) {
          const clickedObject = intersects[0].object;
          if (disks.includes(clickedObject)) {
            const clickedDisk = clickedObject;
            console.log("Selected Disk:", clickedDisk.userData.index); // Debug the selected disk index

            if (!selectedDisk) {
              // Select disk (only if it's the topmost disk on its peg)
              const diskIndex = clickedDisk.userData.index;
              const pegIndex = pegState.findIndex((peg) => peg.includes(diskIndex));

              if (pegState[pegIndex].slice(-1)[0] === diskIndex) {
                selectedDisk = clickedDisk;
                selectedPeg = pegIndex; // Store the current peg
                console.log(`Selected disk ${diskIndex} from peg ${pegIndex}`);
              }
            } else {
              // Determine target peg by checking if it was clicked
              const targetPegIndex = pegs.findIndex(peg => peg === clickedObject);

              console.log("Target Peg Index:", targetPegIndex); // Debug the target peg index

              if (targetPegIndex !== -1 && selectedPeg !== targetPegIndex) {
                const targetPegTopDiskIndex = pegState[targetPegIndex].slice(-1)[0];
                const selectedDiskIndex = selectedDisk.userData.index;

                // Check if move is valid
                if (
                  !targetPegTopDiskIndex || // Peg is empty
                  selectedDiskIndex < targetPegTopDiskIndex // Disk is smaller than top disk
                ) {
                  // Move the disk
                  pegState[selectedPeg].pop();
                  pegState[targetPegIndex].push(selectedDiskIndex);

                  const targetHeight =
                    -2.5 + (pegState[targetPegIndex].length - 1) * (diskHeight + 0.1);

                  // Animate movement using custom animation
                  const newX = pegs[targetPegIndex].position.x;
                  animateDisk(selectedDisk, newX, targetHeight, 500); // Move disk over 500ms

                  console.log(`Moved disk ${selectedDiskIndex} to peg ${targetPegIndex}`);
                } else {
                  console.log("Invalid move!");
                }

                selectedDisk = null; // Reset selection
              }
            }
          }
        }
      });

      // Custom Animation Function (without external libraries)
      function animateDisk(disk, targetX, targetY, duration = 500) {
        const startX = disk.position.x;
        const startY = disk.position.y;
        const startTime = performance.now();

        function animate(time) {
          const elapsedTime = time - startTime;
          const t = Math.min(elapsedTime / duration, 1); // Normalize time (0 to 1)

          // Interpolate positions
          disk.position.x = startX + (targetX - startX) * t;
          disk.position.y = startY + (targetY - startY) * t;

          if (t < 1) {
            window.requestAnimationFrame(animate); // Continue animation
          }
        }

        window.requestAnimationFrame(animate); // Start animation
      }*/

      // Camera position
      camera.position.z = 10;
      
      /*
      // Animation loop
      function animate() {
        window.requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
      animate();*/
      
    
         
    </script>
      
  </body>
</html>